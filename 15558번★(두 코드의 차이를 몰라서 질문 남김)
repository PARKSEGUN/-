문제를 해결하는 법은 쉬웠으나 두개의 코드의 차이가 궁금해서 질문을 남겼다

---------수정 전 코드-------------
    #include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<string>
#include<memory.h>
using namespace std;

int N, K;
char leftMap[222222];
char rightMap[222222];
void Input() {
	memset(leftMap, '1', sizeof(leftMap));
	memset(rightMap, '1', sizeof(rightMap));
	cin >> N >> K;
	string str;
	cin >> str;
	for (int i = 0; i < N; i++) { leftMap[i] = str[i]; }
	cin >> str;
	for (int i = 0; i < N; i++) { rightMap[i] = str[i]; }
}
//map 받을때 -1은 leftMap을 1은 rightMap을 의미함
queue<int> M;
queue<pair<int, int>> q;
bool leftvisited[111111];
bool rightvisited[111111];
void BFS(int Map, int X, int Cnt) {
	M.push(Map);
	q.push({ X,Cnt });
	leftvisited[X] = true;
	while (q.size() != 0) {
		int map = M.front();
		int x = q.front().first;
		int cnt = q.front().second;
		M.pop(); q.pop();

		//cout << map << " " << x << " " << cnt << endl;
		//system("pause");

		if (x >= N) { cout << 1; return; }

		if (map == -1 && leftMap[x + 1] == '1' && leftvisited[x + 1] == false) {
			leftvisited[x + 1] = true;
			M.push(map);
			q.push({ x + 1,cnt + 1 });
		}
		else if (map == 1 && rightMap[x + 1] == '1' && rightvisited[x + 1] == false) {
			rightvisited[x + 1] = true;
			M.push(map);
			q.push({ x + 1,cnt + 1 });
		}

		if (x - 1 > cnt) {
			if (map == -1 && leftMap[x - 1] == '1' && leftvisited[x - 1] == false) {
				leftvisited[x - 1] = true;
				M.push(map);
				q.push({ x - 1,cnt + 1 });
			}
			else if (map == 1 && rightMap[x - 1] == '1' && rightvisited[x - 1] == false) {
				rightvisited[x - 1] = true;
				M.push(map);
				q.push({ x - 1,cnt + 1 });
			}
		}

		if (map == -1 && rightMap[x + K] == '1' && leftvisited[x + K] == false) {
			leftvisited[x + K] = true;
			M.push(map * -1);
			q.push({ x + K,cnt + 1 });
		}
		else if (map == 1 && leftMap[x + K] == '1' && rightvisited[x + K] == false) {
			rightvisited[x + K] = true;
			M.push(map * -1);
			q.push({ x + K,cnt + 1 });
		}
	}
	cout << 0;
}
void Solve() {
	BFS(-1, 0, 0);
}

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	Input();
	Solve();
}








----------수정 코드-------------
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
#include<string>
#include<memory.h>
using namespace std;

int N, K;
int map[2][111111];
void Input() {
	cin >> N >> K;
	string str;
	cin >> str;
	for (int i = 0; i < N; i++) { map[0][i] = str[i] - '0'; }
	cin >> str;
	for (int i = 0; i < N; i++) { map[1][i] = str[i] - '0'; }
}
queue<int> M;
queue<pair<int, int>> q;
bool visited[2][111111];
void BFS(int Map, int X, int Cnt) {
	M.push(Map);
	q.push({ X,Cnt });
	visited[0][0] = true;
	while (q.size() != 0) {
		int m = M.front();
		int x = q.front().first;
		int cnt = q.front().second;
		M.pop(); q.pop();

		//cout << map << " " << x << " " << cnt << endl;
		//system("pause");


		if (x + 1 >= N) { cout << 1; return; }
		else if (map[m][x + 1] == 1 && visited[m][x + 1] == false) {	//앞으로 한칸
			visited[m][x + 1] = true;
			M.push(m);
			q.push({ x + 1,cnt + 1 });
		}

		if (x - 1 > cnt) {
			if (map[m][x - 1] == 1 && visited[m][x - 1] == false) {
				visited[m][x - 1] = true;
				M.push(m);
				q.push({ x - 1,cnt + 1 });
			}
		}

		if (x + K >= N) { cout << 1; return; }
		else if (map[!m][x + K] == 1 && visited[!m][x + K] == false) {
			visited[!m][x + K] = true;
			M.push(!m);
			q.push({ x + K,cnt + 1 });
		}

	}
	cout << 0;
}
void Solve() {
	BFS(0, 0, 0);
}

int main(void) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	Input();
	Solve();
}
