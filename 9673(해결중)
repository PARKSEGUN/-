#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<queue>

#define endl "\n"

using namespace std;

int map[111][111];	//1은 빈 공간, 2은 지날갈 수 없는 벽, 3 는 문
int N, M;
vector<int> prisoner;

void Input() {
	cin >> N >> M;
	for (int i = 0; i < N; i++) {
		string str;
		cin >> str;
		for (int j = 0; j < M; j++) {
			if (str[j] == '*') { map[i][j] = 2; }
			else if (str[j] == '.') { map[i][j] = 1; } 
			else if (str[j] == '#') { map[i][j] = 3; }
			else if (str[j] == '$') { map[i][j] = 1; prisoner.push_back(i); prisoner.push_back(j); }
		}
	}

	//for (int i = 0; i < N; i++) {
	//	for (int j = 0; j < M; j++) {
	//		cout << map[i][j];
	//	}cout << endl;
	//}
}
queue<pair<int, int>> q;
queue<int> door;
bool visited[111][111];
int dix[4] = { 0,0,1,-1 };		//상하좌우
int diy[4] = { 1,-1,0,0 };
int result;
void Solution() {
	q.push({ prisoner[0],prisoner[1] });	//큐에 값 저장
	visited[prisoner[0]][prisoner[1]]=true;
	door.push(0);
	while (q.size() != 0) {
		int x = q.front().first;
		int y = q.front().second;
		cout << x << " " << y << endl;
		int open = door.front();
		q.pop(); door.pop();		//큐에 값 제거
		for (int i = 0; i < 4; i++) {
			int dx = x + dix[i];
			int dy = y + diy[i];

			if (dx >= 0 && dx < N && dy >= 0 && dy < M) {
				if (visited[dx][dy] == false) {
					if (map[dx][dy] == 1) {		//빈공간을 지날때
						q.push({ dx,dy });
						door.push(open);
						visited[dx][dy] = true;
					}
					else if (map[dx][dy] == 3) {		//문을 지날때
						q.push({ dx,dy });
						door.push(open+1);
						visited[dx][dy] = true;
					}
				}
			}
			else {		//맵을 탈출했을 때
				result = open;
				break;
			}
		}
	}
	cout << result;
}


int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	Input();
	Solution();

	return 0;
}
문의 개수에 따라서 visited 변수를 만들어 줘야 하나?
문을 통과했다면 그 문자리는 빈자리로 만들어준다
첫번째 죄수를 통과시켰을때 두번째 죄수가 밖으로 나가는 모든 경우를 따져서 최솟값을 뽑고
그 다음 다시 첫번쨰 죄수가 밖으로 나가는 두번째 방법으로 나가면 다시 두번째 죄수가 밖으로나가는
모든 경우를 실행시켜야하나?
첫번째 죄수가 나가는 길이 한가지 밖에 없다면?
